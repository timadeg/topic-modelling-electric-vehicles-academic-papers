# -*- coding: utf-8 -*-
"""Timothy_Adegbola_Topic_Modelling

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lbjoQKHkBE9gBnnZirzDNZeh77HuxQcq

### CONNECTING TO GOOGLE DRIVE
"""


"""## **IMPORTING NECESSARY LIBRARIES**



"""



import os
import re
import time
import string
import locale
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from collections import Counter
from wordcloud import WordCloud

# Locale settings
def getpreferredencoding(do_setlocale=True):
    return "UTF-8"
locale.getpreferredencoding = getpreferredencoding

# Package installations
#!pip install openpyxl
#!pip install --upgrade xlsxwriter
#!pip install bertopic
#!pip install flair
#!apt-get -qq install -y libfluidsynth1

# NLP related imports
import nltk
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
nltk.download('stopwords')
nltk.download('wordnet')
nltk.download('omw-1.4')

wn = nltk.WordNetLemmatizer()

# Machine learning and clustering imports
from umap import UMAP
from sklearn.cluster import KMeans
from sklearn.feature_extraction.text import CountVectorizer
from sentence_transformers import SentenceTransformer
from transformers.pipelines import pipeline
from hdbscan import hdbscan

# Topic modeling
from bertopic import BERTopic

# Embeddings
from flair.embeddings import (
    TransformerDocumentEmbeddings, 
    WordEmbeddings, 
    DocumentPoolEmbeddings, 
    StackedEmbeddings
)

"""## MERGING PRE-DOWNLOADED JOURNAL PAPERS"""

# COMMENTED TO AVOID RUNNING BY MISTAKE
# #input directories being specified
# folder_path = r'/content/drive/MyDrive/TOPIC MODELLING/Papers'  

# #this functions combine nultiple excel files into a single one
# def combine_excel_files(folder_path):
#     dfs = []
#     for file_name in os.listdir(folder_path):
#         print("File name:", file_name)  # Debugging line
#         if file_name.endswith('.xls'):
#             file_path = os.path.join(folder_path, file_name)
#             df = pd.read_excel(file_path)
#             dfs.append(df)
#     combined_df = pd.concat(dfs, ignore_index=True)
#     return combined_df

# combined_df = combine_excel_files(folder_path)
# duplicates = combined_df[combined_df.duplicated()]
# unique_df = combined_df.drop_duplicates(subset=combined_df.columns[1:], keep='first')

# #output directory being specified
# output_file_path = r'papers.xlsx'

# unique_df.to_excel(output_file_path, index=False, engine='openpyxl')

"""## READING THE EXCEL FILE INTO PANDAS DATAFRAME"""

path = r'papers.xlsx'
dataset = pd.read_excel(path)
dataset

"""## GETTING TO UNDERSTAND THE STUCTURE OF THE DATA"""

# Get the dataset information
print(dataset.info())

"""### CHECKING FOR MISSING OBSERVATION IN EACH COLUMN"""

missing_values = dataset.isnull().sum()

# Convert to a list of tuples
missing_values_list = [(column, missing_count) for column, missing_count in missing_values.items()]

print("Number of missing values in each column:")
missing_values_list

"""## **DATA CLEANING**

### DEALING WITH MISSING VALUES AND FLOAT OBJECTS
"""

# Replace missing values with an empty string and transform floats value to string
dataset['Article Title'] = dataset['Article Title'].fillna('').apply(lambda x: str(x) if isinstance(x, float) else x)
dataset['Abstract'] = dataset['Abstract'].fillna('').apply(lambda x: str(x) if isinstance(x, float) else x)

"""### DROPPING ROWS WITH MISSING ABSTRACT"""

dataset = dataset.dropna(subset=['Abstract'])
# Reset the index
dataset.reset_index(drop=True, inplace=True)

"""### DROPPING DUPLICATES IN ARTICLE TITLE AND ABSTRACT COLUMNS"""

# Assuming your DataFrame is named 'dataset'
data = dataset.drop_duplicates(subset=['Article Title', 'Abstract'], keep='first')

# Reset the index
data.reset_index(drop=True, inplace=True)

"""## EXPLORATORY DATA ANALYSIS

### 1. Length distribution of Article Titles, Abstracts
Analyzing the distribution of lengths (number of characters or words) for each of these columns.
This can help identify any potential issues with very short or very long texts.
"""

def get_text_statistics(data, column):
    word_counts = data[column].str.split().apply(len)
    avg_words = word_counts.mean()
    std_dev_words = word_counts.std()
    return avg_words, std_dev_words

avg_title_words, std_dev_title_words = get_text_statistics(data, 'Article Title')
avg_abstract_words, std_dev_abstract_words = get_text_statistics(data, 'Abstract')

print(f"Average number of words in 'Article Title': {avg_title_words:.2f}")
print(f"Standard deviation of words in 'Article Title': {std_dev_title_words:.2f}")

print(f"Average number of words in 'Abstract': {avg_abstract_words:.2f}")
print(f"Standard deviation of words in 'Abstract': {std_dev_abstract_words:.2f}")

def plot_length_distribution(data, column, title):
    lengths = data[column].str.len()
    plt.figure(figsize=(10, 5))
    sns.histplot(lengths, kde=False, bins=50)
    plt.title(f'{title} Length Distribution')
    plt.xlabel('Length')
    plt.ylabel('Frequency')
    plt.show()

plot_length_distribution(data, 'Article Title', 'Article Title')
plot_length_distribution(data, 'Abstract', 'Abstract')

"""### 2. Distribution of Publication Years"""

plt.figure()
year_counts = dataset['Publication Year'].value_counts().sort_index()
for year, count in year_counts.items():
  print(f"{int(year)}: {count}")


ax = year_counts.plot(kind='bar')
plt.xlabel('Publication Year')
plt.ylabel('Number of Papers')
plt.title('Distribution of Publication Years')

# Format x-axis tick labels as integers
ax.set_xticklabels([int(float(label.get_text())) for label in ax.get_xticklabels()])

plt.show()

"""### 3. Visualizing the paper types



"""

import textwrap
# Plot the bar chart for document types
plt.figure()
document_type_counts = dataset['Document Type'].value_counts().head(6)
print(document_type_counts)  # Display the top 5 document types

ax = document_type_counts.plot(kind='bar')
plt.xlabel('Document Type')
plt.ylabel('Number of Papers')
plt.title('Top 6 Document Types')

# Wrap x-axis tick labels and rotate them horizontally
wrapped_labels = [textwrap.fill(label.get_text(), width=12) for label in ax.get_xticklabels()]
ax.set_xticklabels(wrapped_labels, rotation=0, ha='center')

plt.show()

"""### 4. Checking the top 10 sources of the papers




"""

# Plot the bar chart for source titles
plt.figure()
source_title_counts = dataset['Source Title'].value_counts().head(10)
print(source_title_counts)  # Display the top 10 sources

source_title_counts.plot(kind='bar')
plt.xlabel('Source Title')
plt.ylabel('Number of Papers')
plt.title('Top 10 Sources with Highest Number of Publications')

plt.show()

"""#### 5. Statistical Analysis of numerical columns

"""

quantitative_columns = ['Cited Reference Count', 'Times Cited, WoS Core', '180 Day Usage Count', 'Since 2013 Usage Count']
summary_statistics = data[quantitative_columns].describe()
summary_statistics

"""### 6. Top 20 Cited Papers"""

top_cited_papers = data.nlargest(20, 'Times Cited, All Databases')[['Article Title', 'Authors', 'Times Cited, All Databases']]
print("Top 20 most cited papers:")
top_cited_papers

# Group the dataset by 'Publication Year' and calculate the mean of 'Times Cited, All Databases'
citation_trend = dataset.groupby('Publication Year')['Times Cited, All Databases'].mean()

# Print the average citation counts for each year
print("Average citation counts by year:")
for year, counts in citation_trend.items():
  print(f"{int(year)}: {round(counts)}")

# Plot the trend of average citation counts over time
plt.figure()
citation_trend.plot(kind='line')
plt.xlabel('Publication Year')
plt.ylabel('Average Times Cited')
plt.title('Trend of Average Citation Counts Over Time')
plt.show()

"""## DATA PREPROCESSING

### Dropping Columns not needed
"""

columns_of_interest = ['Article Title', 'Abstract']
data = data[columns_of_interest]
data

"""### Joining Title and Abstract"""

data = data[['Article Title', 'Abstract']].copy()
data['Title + Abstract'] = data['Article Title'] + ' ' + data['Abstract']

"""### Stop words and punctuation removal, Lemmatization, Lower Case Conversion


"""

def clean_text_update(text):
    def remove_punctuation(text):
        return text.translate(str.maketrans('', '', string.punctuation))

    # Convert text to lowercase
    text = text.lower()

    # Remove punctuation
    text = remove_punctuation(text)

    # Remove stopwords
    stopwords = nltk.corpus.stopwords.words('english')
    custom_stopwords = ['elsevier', 'ltd', 'right', 'reserved', 'from', 'subject', 're', 'edu', 'use']  # custom stopwords
    stopwords.extend(custom_stopwords)  # extend the list with custom stopwords

    words = [w for w in text.split() if w.lower() not in stopwords]
    text = ' '.join(words)

    # Lemmatization
    wn = WordNetLemmatizer()
    lemmatized_words = [wn.lemmatize(w) for w in words]
    text = ' '.join(lemmatized_words)

    return text

# Apply the clean_text function to the 'Title + Abstract' column
data['Cleaned_Title + Abstract'] = data['Title + Abstract'].apply(clean_text_update)

"""## MORE EDA

### 6. Word cloud visualization
Creating word clouds for the 'Title_Abstract_lemmatized' column to get a visual representation of the most frequent words in the dataset.
"""

def plot_wordcloud(text, title):
    wordcloud = WordCloud(max_font_size=50, max_words=100, background_color="white").generate(text)
    plt.figure(figsize=(10, 5))
    plt.imshow(wordcloud, interpolation="bilinear")
    plt.axis("off")
    plt.title(title)
    plt.show()

all_text = ' '.join(data['Cleaned_Title + Abstract'])
plot_wordcloud(all_text, 'Word Cloud for Cleaned_Title + Abstract')

"""### Function to Print and Display BiGrams and TriGrams"""

from nltk import bigrams, trigrams
# Convert the cleaned text to a list of words
data['Cleaned_Words'] = data['Cleaned_Title + Abstract'].apply(lambda x: x.split())

# Create bigrams
data['Bigrams'] = data['Cleaned_Words'].apply(lambda x: list(bigrams(x)))

# Create trigrams
data['Trigrams'] = data['Cleaned_Words'].apply(lambda x: list(trigrams(x)))

# Flatten the list of bigrams and count the frequency of each bigram
bigrams_list = [bigram for sublist in data['Bigrams'].tolist() for bigram in sublist]
bigram_counts = Counter(bigrams_list)

# Flatten the list of trigrams and count the frequency of each trigram
trigrams_list = [trigram for sublist in data['Trigrams'].tolist() for trigram in sublist]
trigram_counts = Counter(trigrams_list)

def plot_ngrams(ngrams, ngram_counts, title):
    plt.figure(figsize=(10, 5))
    colors = plt.cm.viridis(np.linspace(0, 1, 10))  # generate 10 different colors
    plt.barh(range(len(ngrams)), ngram_counts, color=colors)
    plt.yticks(range(len(ngrams)), [' '.join(ngram) for ngram in ngrams])
    plt.xlabel('Frequency')
    plt.ylabel(title)
    plt.title(f'Top 10 Most Frequent {title}')
    plt.gca().invert_yaxis()  # invert the y-axis to have the most frequent ngram at the top
    plt.show()

"""### 7. Top frequent words (Unigram Analysis)
Finding the most frequent words in the 'Title + Abstract_lemmatized' column and visualizing them using a bar plot.
"""

from nltk import FreqDist

# Flatten the list of words and create a frequency distribution
words_list = [word for sublist in data['Cleaned_Words'].tolist() for word in sublist]
word_counts = FreqDist(words_list)

# List out and plot the top 10 most common words
words, word_counts = zip(*word_counts.most_common(10))
for word, count in zip(words, word_counts):
    print(f'{word}: {count:,}')
plot_ngrams(words, word_counts, title='Words (Unigrams)')

"""### List and Display Bigrams"""

# List out and plot the top 10 most common bigrams
bigrams, bigram_counts = zip(*bigram_counts.most_common(10))
for bigram, count in zip(bigrams, bigram_counts):
    print(f'{bigram[0]} {bigram[1]}: {count:,}')
plot_ngrams(bigrams, bigram_counts, title='Bigrams')

"""### List and Display Trigrams"""

# In a new cell, list out and plot the top 10 most common trigrams
trigrams, trigram_counts = zip(*trigram_counts.most_common(10))
for trigram, count in zip(trigrams, trigram_counts):
    print(f'{trigram[0]} {trigram[1]} {trigram[2]}: {count:,}')
plot_ngrams(trigrams, trigram_counts, title='Trigrams')

"""# 1. TOPIC MODELLING USING BERTOPIC:

### BERTopic Model Initialization and Configuration
"""

# Initiate UMAP
umap_model = UMAP(n_neighbors=15, 
                  n_components=5, 
                  min_dist=0.0, 
                  metric='cosine', 
                  random_state=100)
# Clustering model
kmeans_model = KMeans(n_clusters=8)
# Initiate a sentence transformer model
sentence_model = SentenceTransformer("paraphrase-albert-small-v2")
# Initiate a pretrained model
hf_model = pipeline("feature-extraction", model="distilroberta-base")

# Initiate a pretrained embedding model
roberta_model = TransformerDocumentEmbeddings('roberta-base')
# Initiate another pretrained embedding model
glove_embedding = WordEmbeddings('crawl')
document_glove_embeddings = DocumentPoolEmbeddings([glove_embedding])
# Stack the two pretrained embedding models
stacked_embeddings = StackedEmbeddings(embeddings=[roberta_model, 
document_glove_embeddings])

# Count vectorizer
vectorizer_model = CountVectorizer(min_df=10)

# Initiate BERTopic
topic_model8 = BERTopic(umap_model=umap_model, language="english", calculate_probabilities=True,hdbscan_model=kmeans_model, n_gram_range=(1, 3))

"""### RUNNING THE BERTopic MODEL"""

import time
# Start the timer
start_time_bert_8 = time.time()

# Run BERTopic model
topics, probabilities = topic_model8.fit_transform(data['Cleaned_Title + Abstract'])

# Stop the timer
end_time_bert8 = time.time()

time_taken_bert8 = end_time_bert8 - start_time_bert_8
# Print the time taken
print(f"Time taken to train the topic modeling model: {time_taken_bert8} seconds")

# Get the list of topics
topic_model8.get_topic_info()

num_topics = len(topic_model8.get_topic_info())

for i in range(num_topics):
    print(f"Topic {i}:")
    terms = topic_model8.get_topic(i)
    for term, weight in terms:
        print(f"  {term}: {weight:.4f}")
    print()

# Visualize top topic keywords
topic_model8.visualize_barchart(top_n_topics=8)

# Visualize term rank decrease
topic_model8.visualize_term_rank()

# Visualize intertopic distance
topic_model8.visualize_topics()

# Visualize connections between topics using hierachical clustering
topic_model8.visualize_hierarchy(top_n_topics=10)

# Visualize similarity using heatmap
topic_model8.visualize_heatmap()

# Get the topic predictions
topic_prediction = topic_model8.topics_[:]
# Save the predictions in the dataframe
data['topic_prediction'] = topic_prediction
# Take a look at the data
data

# New data for the review
new_review = "The Power Grid in Nigeria collapsed a total of 8 times in 2022."
# Find topics
num_of_topics = 3
similar_topics, similarity = topic_model8.find_topics(new_review, top_n=num_of_topics); 
# Print results
print(f'The top {num_of_topics} similar topics are {similar_topics}, and the similarities are {np.round(similarity,2)}')

# Print the top keywords for the top similar topics
for i in range(num_of_topics):
  print(f'The top keywords for topic {similar_topics[i]} are:')
  print(topic_model8.get_topic(similar_topics[i]))

"""### Saving the Model"""

# Save the topic model
#topic_model8.save("")	
# Load the topic model
#my_model8 = BERTopic.load("/content/drive/MyDrive/TOPIC MODELLING/NLP2_Bertopic_topic_model8")

"""# 2a. TOPIC MODELLING USING LDA gensim library's LdaMulticore:

---


"""


import gensim
import gensim.corpora as corpora
from gensim.utils import simple_preprocess
from nltk.corpus import stopwords
import nltk
nltk.download('stopwords')
import os
import pickle
import pyLDAvis
import pyLDAvis.gensim_models

"""### Transforming the Data to List"""

def sent_to_words(sentences):
    for sentence in sentences:
        yield(gensim.utils.simple_preprocess(str(sentence), deacc=True))

data_lda1 = data['Cleaned_Title + Abstract'].values.tolist()
data_words8 = list(sent_to_words(data_lda1))

"""### Creating a dictionary and corpus from the tokenized text:"""

id2word = corpora.Dictionary(data_words8)
texts = data_words8
corpus = [id2word.doc2bow(text) for text in texts]

"""### Building the LDA model"""

num_topics = 8  #setting the number of clusters(topics)
start_time_lda8 = time.time() # record the start time

lda_model8 = gensim.models.LdaModel(corpus=corpus, id2word=id2word, num_topics=num_topics, random_state=42)

end_time_lda8 = time.time() # record the end time

time_taken_lda8 = end_time_lda8 - start_time_lda8
# Print the time taken
print(f"Time taken to train the LDA model using gensim library: {time_taken_lda8} seconds")

"""### Printing the keywords in each topic"""

from pprint import pprint
pprint(lda_model8.print_topics())
doc_lda = lda_model8[corpus]

"""### PREPARING AND VISUALIZING THE LDA MODEL USING pyLDAvis"""

import pyLDAvis.gensim_models
from multiprocessing import Pool
import tqdm





































"""### TIME TAKEN FOR 8 CLUSTERS"""

import matplotlib.pyplot as plt

# Set up the data
methods = ['BERT', 'LDA Gensim']
time_taken8 = [round(time_taken_bert8), round(time_taken_lda8)]
colors = ['#4B8BBE', '#7B6F8B']

# Create the subplots
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6), sharey=False)

# Linear scale bar chart
ax1.bar(methods, time_taken8, color=colors)
ax1.set_xlabel('Methods')
ax1.set_ylabel('Time Taken (seconds)')
ax1.set_title('Time Taken by Topic Modeling Methods (Linear Scale)')

for i, value in enumerate(time_taken8):
    ax1.text(i, value + 50, str(value), ha='center', fontsize=12)

# Log scale bar chart
ax2.bar(methods, time_taken8, color=colors, log=True)
ax2.set_yscale("log") # Set y-axis to log scale
ax2.set_xlabel('Methods')
ax2.set_title('Time Taken by Topic Modeling Methods (Log Scale)')

for i, value in enumerate(time_taken8):
    ax2.text(i, value * 1.1, str(value), ha='center', fontsize=12)

# Show the charts
plt.show()



"""### USING A VERY HIGH NUMBER OF TOPICS i.e 15

### Bertopic
"""

# Initiate UMAP
umap_model = UMAP(n_neighbors=15, 
                  n_components=5, 
                  min_dist=0.0, 
                  metric='cosine', 
                  random_state=100)
# Clustering model
kmeans_model = KMeans(n_clusters=15)
# Initiate a sentence transformer model
sentence_model = SentenceTransformer("paraphrase-albert-small-v2")
# Initiate a pretrained model
hf_model = pipeline("feature-extraction", model="distilroberta-base")

# Initiate a pretrained embedding model
roberta_model = TransformerDocumentEmbeddings('roberta-base')
# Initiate another pretrained embedding model
glove_embedding = WordEmbeddings('crawl')
document_glove_embeddings = DocumentPoolEmbeddings([glove_embedding])
# Stack the two pretrained embedding models
stacked_embeddings = StackedEmbeddings(embeddings=[roberta_model, 
document_glove_embeddings])

# Count vectorizer
vectorizer_model = CountVectorizer(min_df=10)

# Initiate BERTopic
topic_model15 = BERTopic(umap_model=umap_model, language="english", calculate_probabilities=True,hdbscan_model=kmeans_model, n_gram_range=(1, 3))

import time
# Start the timer
start_time_bert15 = time.time()

# Run BERTopic model
topics, probabilities = topic_model15.fit_transform(data['Cleaned_Title + Abstract'])

# Stop the timer
end_time_bert15 = time.time()

time_taken_bert15 = end_time_bert15 - start_time_bert15
# Print the time taken
print(f"Time taken to train the topic modeling model: {time_taken_bert15} seconds")

"""### Printing the Topics"""

num_topics = len(topic_model15.get_topic_info())  

for i in range(num_topics):
    print(f"Topic {i}:")
    terms = topic_model15.get_topic(i)
    for term, weight in terms:
        print(f"  {term}: {weight:.4f}")
    print()

# Get the list of topics
topic_model15.get_topic_info()

# Visualize top topic keywords
topic_model15.visualize_barchart(top_n_topics=15)

"""## TRAINING LDA 15 CLUSTERS"""

num_topics = 15  #setting the number of clusters(topics)
start_time_lda15 = time.time() # record the start time

lda_model15 = gensim.models.LdaModel(corpus=corpus, id2word=id2word, num_topics=num_topics, random_state=42)

end_time_lda15 = time.time() # record the end time

time_taken_lda15 = end_time_lda15 - start_time_lda15
# Print the time taken
print(f"Time taken to train the LDA model using gensim library: {time_taken_lda15} seconds")

from pprint import pprint
pprint(lda_model15.print_topics())
doc_lda = lda_model15[corpus]






















"""### TIME TAKEN FOR 15 CLUSTERS"""

import matplotlib.pyplot as plt

# Set up the data
methods = ['BERT', 'LDA Gensim']
time_taken15 = [round(time_taken_bert15), round(time_taken_lda15)]
colors = ['#4B8BBE', '#7B6F8B']

# Create the subplots
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6), sharey=False)

# Linear scale bar chart
ax1.bar(methods, time_taken15, color=colors)
ax1.set_xlabel('Methods')
ax1.set_ylabel('Time Taken (seconds)')
ax1.set_title('Time Taken by Topic Modeling Methods (Linear Scale)')

for i, value in enumerate(time_taken15):
    ax1.text(i, value + 50, str(value), ha='center', fontsize=12)

# Log scale bar chart
ax2.bar(methods, time_taken8, color=colors, log=True)
ax2.set_yscale("log") # Set y-axis to log scale
ax2.set_xlabel('Methods')
ax2.set_title('Time Taken by Topic Modeling Methods (Log Scale)')

for i, value in enumerate(time_taken15):
    ax2.text(i, value * 1.1, str(value), ha='center', fontsize=12)

# Show the charts
plt.show()

"""### COMPARING THE TIME TAKEN FOR BOTH MODELS WITH 8 AND 15 CLUSTERS"""

import numpy as np
import matplotlib.pyplot as plt

# Set up the data
methods = ['BERT-8', 'LDA-8', 'BERT-15', 'LDA-15']
time_taken = [round(time_taken_bert8), round(time_taken_lda8), round(time_taken_bert15), round(time_taken_lda15)]
colors = ['#4B8BBE', '#7B6F8B', '#306998', '#644E5B']

# Create the bar chart
plt.figure(figsize=(10,6))
bars = plt.bar(methods, time_taken, color=colors, edgecolor='grey')

# Add the data value on top of each bar
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval + 0.05, round(yval), ha='center', va='bottom')

# Add labels and title
plt.xlabel('Methods', fontweight='bold')
plt.ylabel('Time Taken (seconds)', fontweight='bold')

# Set y-axis to log scale
plt.yscale('log')

plt.title('Time Taken by Topic Modeling Methods (Log Scale)')
plt.show()

